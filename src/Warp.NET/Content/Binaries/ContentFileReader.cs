using Warp.NET.Extensions;

namespace Warp.NET.Content.Binaries;

/// <summary>
/// Reads the binary content file generated by the <see cref="ContentFileWriter"/>, constructs the content objects, and assigns those objects to the properties in the source generated content classes using reflection.
/// </summary>
public static class ContentFileReader
{
	public static void Read(string contentPath, Assembly gameAssembly)
	{
		if (!File.Exists(contentPath))
			throw new InvalidOperationException("Content file does not exist.");

		using FileStream fs = new(contentPath, FileMode.Open);
		using BinaryReader br = new(fs);
		ushort tocEntryCount = br.ReadUInt16();

		TocEntry[] tocEntries = new TocEntry[tocEntryCount];
		for (int i = 0; i < tocEntryCount; i++)
		{
			ContentType contentType = (ContentType)br.ReadByte();
			string name = br.ReadString();
			uint length = br.ReadUInt32();

			tocEntries[i] = new(contentType, name, length);
		}

		Type[] types = gameAssembly.GetTypes();
		Type shadersType = types.Single(t => t.Name == "Shaders");
		Type texturesType = types.Single(t => t.Name == "Textures");
		Type soundsType = types.Single(t => t.Name == "Sounds");
		Type meshesType = types.Single(t => t.Name == "Meshes");
		Type modelsType = types.Single(t => t.Name == "Models");

		Dictionary<string, ShaderSourceCollection> shaderSourceCollections = new();

		foreach (TocEntry tocEntry in tocEntries)
		{
			long pos = br.BaseStream.Position;

			switch (tocEntry.ContentType)
			{
				case ContentType.VertexShader: SetShaderSource(shaderSourceCollections, br, tocEntry.Name, (int)tocEntry.Length, (ssc, str) => ssc.VertexCode = str); break;
				case ContentType.GeometryShader: SetShaderSource(shaderSourceCollections, br, tocEntry.Name, (int)tocEntry.Length, (ssc, str) => ssc.GeometryCode = str); break;
				case ContentType.FragmentShader: SetShaderSource(shaderSourceCollections, br, tocEntry.Name, (int)tocEntry.Length, (ssc, str) => ssc.FragmentCode = str); break;

				case ContentType.TextureW1: SetProperty(texturesType, tocEntry.Name, ConstructTextureW1(br)); break;
				case ContentType.TextureW8: SetProperty(texturesType, tocEntry.Name, ConstructTextureW8(br)); break;
				case ContentType.TextureWa16: SetProperty(texturesType, tocEntry.Name, ConstructTextureWa16(br)); break;
				case ContentType.TextureRgb24: SetProperty(texturesType, tocEntry.Name, ConstructTextureRgb24(br)); break;
				case ContentType.TextureRgba32: SetProperty(texturesType, tocEntry.Name, ConstructTextureRgba32(br)); break;

				case ContentType.Sound: SetProperty(soundsType, tocEntry.Name, ConstructSound(br)); break;

				case ContentType.Mesh: SetProperty(meshesType, tocEntry.Name, ConstructMesh(br)); break;
				case ContentType.Model: SetProperty(modelsType, tocEntry.Name, ConstructModel(br)); break;

				default: throw new NotSupportedException($"Reading {nameof(ContentType)} '{tocEntry.ContentType}' is not supported.");
			}

			if (br.BaseStream.Position != pos + tocEntry.Length)
				throw new InvalidOperationException($"Toc entry is {tocEntry.Length} bytes, but binary reader read {br.BaseStream.Position - pos} bytes!");
		}

		foreach (KeyValuePair<string, ShaderSourceCollection> shaderSource in shaderSourceCollections)
		{
			if (shaderSource.Value.VertexCode == null)
				throw new InvalidOperationException($"Vertex shader source for '{shaderSource.Key}' not found.");
			if (shaderSource.Value.FragmentCode == null)
				throw new InvalidOperationException($"Fragment shader source for '{shaderSource.Key}' not found.");

			SetProperty(shadersType, shaderSource.Key, new Shader(shaderSource.Value.VertexCode, shaderSource.Value.GeometryCode, shaderSource.Value.FragmentCode));
		}
	}

	private static void SetShaderSource(IDictionary<string, ShaderSourceCollection> shaderSources, BinaryReader br, string shaderName, int shaderLength, Action<ShaderSourceCollection, string> setShaderSource)
	{
		string str = Encoding.UTF8.GetString(br.ReadBytes(shaderLength));
		if (shaderSources.TryGetValue(shaderName, out ShaderSourceCollection? value))
		{
			setShaderSource(value, str);
		}
		else
		{
			ShaderSourceCollection ssc = new();
			setShaderSource(ssc, str);
			shaderSources.Add(shaderName, ssc);
		}
	}

	private static void SetProperty<TContent>(Type containerType, string contentName, TContent contentObject)
		where TContent : class
	{
		PropertyInfo? property = containerType.GetProperty(contentName);
		property?.SetValue(null, contentObject);
	}

	private static Texture ConstructTextureW1(BinaryReader br)
	{
		ushort width = br.ReadUInt16();
		ushort height = br.ReadUInt16();

		int colorDataSize = (int)Math.Ceiling(width * height / 8f);
		byte[] colorBuffer = br.ReadBytes(colorDataSize);
		BitArray binaryColors = new(colorBuffer);

		byte[] colors = new byte[width * height * 4];
		for (int i = 0; i < colors.Length / 4; i++)
		{
			byte unifiedValue = binaryColors[i] ? (byte)0xFF : (byte)0x00;
			for (int j = 0; j < 4; j++)
				colors[i * 4 + j] = unifiedValue;
		}

		return new(width, height, colors);
	}

	private static Texture ConstructTextureW8(BinaryReader br)
	{
		ushort width = br.ReadUInt16();
		ushort height = br.ReadUInt16();

		byte[] colors = new byte[width * height * 4];
		for (int i = 0; i < colors.Length; i += 4)
		{
			byte colorComponent = br.ReadByte();
			colors[i] = colorComponent;
			colors[i + 1] = colorComponent;
			colors[i + 2] = colorComponent;
			colors[i + 3] = 0xFF;
		}

		return new(width, height, colors);
	}

	private static Texture ConstructTextureWa16(BinaryReader br)
	{
		ushort width = br.ReadUInt16();
		ushort height = br.ReadUInt16();

		byte[] colors = new byte[width * height * 4];
		for (int i = 0; i < colors.Length; i += 4)
		{
			byte colorComponent = br.ReadByte();
			colors[i] = colorComponent;
			colors[i + 1] = colorComponent;
			colors[i + 2] = colorComponent;
			colors[i + 3] = br.ReadByte();
		}

		return new(width, height, colors);
	}

	private static Texture ConstructTextureRgb24(BinaryReader br)
	{
		ushort width = br.ReadUInt16();
		ushort height = br.ReadUInt16();

		byte[] colors = new byte[width * height * 4];
		for (int i = 0; i < colors.Length; i++)
			colors[i] = i % 4 == 3 ? (byte)0xFF : br.ReadByte();

		return new(width, height, colors);
	}

	private static Texture ConstructTextureRgba32(BinaryReader br)
	{
		ushort width = br.ReadUInt16();
		ushort height = br.ReadUInt16();
		return new(width, height, br.ReadBytes(width * height * 4));
	}

	private static Sound ConstructSound(BinaryReader br)
	{
		short channels = br.ReadInt16();
		int sampleRate = br.ReadInt32();
		short bitsPerSample = br.ReadInt16();
		int size = br.ReadInt32();
		byte[] data = br.ReadBytes(size);
		return new(channels, sampleRate, bitsPerSample, data.Length, data);
	}

	private static Model ConstructModel(BinaryReader br)
	{
		ushort meshCount = br.ReadUInt16();

		Dictionary<string, Mesh> meshes = new();
		for (int i = 0; i < meshCount; i++)
		{
			string useMaterial = br.ReadString();
			meshes.Add(useMaterial, ConstructMesh(br));
		}

		return new(meshes);
	}

	private static Mesh ConstructMesh(BinaryReader br)
	{
		Span<Vector3> positions = stackalloc Vector3[br.ReadUInt16()];
		Span<Vector2> textures = stackalloc Vector2[br.ReadUInt16()];
		Span<Vector3> normals = stackalloc Vector3[br.ReadUInt16()];
		Span<Face> faces = stackalloc Face[br.ReadUInt16()];

		for (int i = 0; i < positions.Length; i++)
			positions[i] = br.ReadVector3AsHalfPrecision();

		for (int i = 0; i < textures.Length; i++)
			textures[i] = br.ReadVector2AsHalfPrecision();

		for (int i = 0; i < normals.Length; i++)
			normals[i] = br.ReadVector3AsHalfPrecision();

		for (int i = 0; i < faces.Length; i++)
			faces[i] = new(br.ReadUInt16(), br.ReadUInt16(), br.ReadUInt16());

		Vertex[] outVertices = new Vertex[faces.Length];
		uint[] outFaces = new uint[faces.Length];
		for (int i = 0; i < faces.Length; i++)
		{
			ushort t = faces[i].Texture;

			outVertices[i] = new(
				positions[faces[i].Position - 1],
				textures.Length > t - 1 && t > 0 ? textures[t - 1] : default, // TODO: Separate face type?
				normals[faces[i].Normal - 1]);
			outFaces[i] = (ushort)i;
		}

		return new(outVertices, outFaces, TriangleRenderMode.Triangles);
	}

	private sealed class ShaderSourceCollection
	{
		public string? VertexCode { get; set; }
		public string? GeometryCode { get; set; }
		public string? FragmentCode { get; set; }
	}
}
